CommitID$~CreatedAt$~Actor$~IssueBody$~Labels$~Locked$~Title$~CreatedAt$~UpdateAt$~Assignee$~State$~UserLogin$~UserId$~Milestone$~ClosedAt$~Assignees
None$~2017-02-02T01:03:14Z$~hmkim$~"I tried to loading the taxonomy into sqlite3 database.    `perl load_ncbi_taxonomy.pl --dbname database --driver SQLite --download --directory db_work`  > Downloading NCBI taxon database to db_work > Loading NCBI taxon database in db_work: >         ... retrieving all taxon nodes in the database >         ... reading in taxon nodes from nodes.dmp >         ... insert / update / delete taxon nodes > Can't call method "execute" on an undefined value at load_ncbi_taxonomy.pl line 465.  Can you check it ? "$~[]$~False$~"load_ncbi_taxonomy.pl (Can't call method "execute" on an undefined value)"$~2016-10-10T14:35:31Z$~2017-02-02T01:03:14Z$~None$~closed$~hmkim$~4966343$~None$~2017-02-02T01:03:14Z$~[]
b5e2109d0426ba427a9c63d1a5fd36dc413023f3$~2016-10-23T23:32:16Z$~ArBaDaCarBa$~"Copying the old issue from https://redmine.open-bio.org/issues/2839 which I filed 22 May 2009, about seven years ago:  > This issue was originally reported as Biopython Bug 2833, a data corruption when (re)importing a record which matched/clashed an existing entry in the database. >  > On MysQL (and presumably Oracle etc), this triggered an error (good), but on PostgreSQL the database was silently corrupted. This was traced so some RULES in the BioSQL PostgreSQL schema added for bioperl-db, as explained here (and in the PostgreSQL schema), >  > http://lists.open-bio.org/pipermail/biopython-dev/2009-May/006088.html >  > Hilmar wrote: >  > Indeed, I'd almost forgotten. The rules are there mostly as a remnant from > earlier versions of PostgreSQL to support transactional loading the way > bioperl-db (the object-relational mapping for BioPerl) is optimized. You > probably don't need them anywhere else. >  > -hilmar >  > <gory-details> > Bioperl-db is optimized such that entities that very likely don't exist yet > in the database are attempted for insert right away. If the insert fails due > to a unique key violation, the record is looked up (and then expected to be > found). In Oracle and MySQL you can do this and the transaction remains > healthy; i.e., you can commit the transaction later and all statements > except those that failed will be committed. In PostgreSQL any failed > statement dooms the entire transaction, and the only way out is a rollback. > In this case, if you want the loading of one sequence record as one > transaction, failing to insert a single feature record will doom the entire > sequence load and you would need to start over with the sequence. To fix > this, I wrote the rules, which in essence do do the lookups for PostgreSQL > that the bioperl-db code would otherwise avoid, and on insert do nothing if > the record is found, which results in zero rows affected when you would > expect one (which is what bioperl-db cues off of and then triggers a > lookup). > The right way to do this meanwhile is to use nested transactions, which > PostgreSQL supports since v8.0.x, but I haven't gotten around to implement > support for that in Bioperl-db. > </gory-details> >  > As discussed on the BioSQL (and Biopython) mailing lists this bug is to first add a big warning about this issue to the INSTALL notes for PostgreSQL (i.e. recommend removing the RULES section if not using bioperl-db): >  > http://code.open-bio.org/svnweb/index.cgi/biosql/view/biosql-schema/trunk/INSTALL >  > Secondly, once bioperl-db has been updated to use nested transactions (which will require PostgreSQL v8.0.x or later), then we can remove the rules themselves: > http://code.open-bio.org/svnweb/index.cgi/biosql/view/biosql-schema/trunk/sql/biosqldb-pg.sql  And my comment from the same year:  > Just to note for Biopython (Bug 2833) we now have a work around in place in our repository. This is at the cost of a run time overhead (an extra query per import) and some code complexity, and I regard it as a short term hack. >  > On PostgreSQL Biopython will check if the rules are present, and if they are issue a warning. Then, before each record import an extra query checks to see if the uniqueness constraint would be violated, and if so we raise an error. >  > Once the BioSQL schema is updated to remove the rules, we can drop this hack, because then the database itself will raise an error.  The Biopython issue referred to was https://redmine.open-bio.org/issues/2833 and the fix this refers to is https://github.com/biopython/biopython/commit/21b0ba9510d1d14671c4745cc930845f54f9b378  Biopython looks for either `rule_bioentry_i1` or `rule_bioentry_i2` (rather than the full set of these potentially problematic rules) and will issue a warning if present. "$~[]$~False$~"Bugzilla/RedMine issue 2839 - Remove RULES in BioSQL PostgreSQL schema"$~2016-06-03T13:26:34Z$~2016-06-03T13:44:26Z$~None$~open$~peterjc$~63959$~None$~None$~[]
5618a68c720cef2df3e7273fa3939836f5ecc5fd$~2016-06-03T13:33:12Z$~peterjc$~"Copying the old issue from https://redmine.open-bio.org/issues/2839 which I filed 22 May 2009, about seven years ago:  > This issue was originally reported as Biopython Bug 2833, a data corruption when (re)importing a record which matched/clashed an existing entry in the database. >  > On MysQL (and presumably Oracle etc), this triggered an error (good), but on PostgreSQL the database was silently corrupted. This was traced so some RULES in the BioSQL PostgreSQL schema added for bioperl-db, as explained here (and in the PostgreSQL schema), >  > http://lists.open-bio.org/pipermail/biopython-dev/2009-May/006088.html >  > Hilmar wrote: >  > Indeed, I'd almost forgotten. The rules are there mostly as a remnant from > earlier versions of PostgreSQL to support transactional loading the way > bioperl-db (the object-relational mapping for BioPerl) is optimized. You > probably don't need them anywhere else. >  > -hilmar >  > <gory-details> > Bioperl-db is optimized such that entities that very likely don't exist yet > in the database are attempted for insert right away. If the insert fails due > to a unique key violation, the record is looked up (and then expected to be > found). In Oracle and MySQL you can do this and the transaction remains > healthy; i.e., you can commit the transaction later and all statements > except those that failed will be committed. In PostgreSQL any failed > statement dooms the entire transaction, and the only way out is a rollback. > In this case, if you want the loading of one sequence record as one > transaction, failing to insert a single feature record will doom the entire > sequence load and you would need to start over with the sequence. To fix > this, I wrote the rules, which in essence do do the lookups for PostgreSQL > that the bioperl-db code would otherwise avoid, and on insert do nothing if > the record is found, which results in zero rows affected when you would > expect one (which is what bioperl-db cues off of and then triggers a > lookup). > The right way to do this meanwhile is to use nested transactions, which > PostgreSQL supports since v8.0.x, but I haven't gotten around to implement > support for that in Bioperl-db. > </gory-details> >  > As discussed on the BioSQL (and Biopython) mailing lists this bug is to first add a big warning about this issue to the INSTALL notes for PostgreSQL (i.e. recommend removing the RULES section if not using bioperl-db): >  > http://code.open-bio.org/svnweb/index.cgi/biosql/view/biosql-schema/trunk/INSTALL >  > Secondly, once bioperl-db has been updated to use nested transactions (which will require PostgreSQL v8.0.x or later), then we can remove the rules themselves: > http://code.open-bio.org/svnweb/index.cgi/biosql/view/biosql-schema/trunk/sql/biosqldb-pg.sql  And my comment from the same year:  > Just to note for Biopython (Bug 2833) we now have a work around in place in our repository. This is at the cost of a run time overhead (an extra query per import) and some code complexity, and I regard it as a short term hack. >  > On PostgreSQL Biopython will check if the rules are present, and if they are issue a warning. Then, before each record import an extra query checks to see if the uniqueness constraint would be violated, and if so we raise an error. >  > Once the BioSQL schema is updated to remove the rules, we can drop this hack, because then the database itself will raise an error.  The Biopython issue referred to was https://redmine.open-bio.org/issues/2833 and the fix this refers to is https://github.com/biopython/biopython/commit/21b0ba9510d1d14671c4745cc930845f54f9b378  Biopython looks for either `rule_bioentry_i1` or `rule_bioentry_i2` (rather than the full set of these potentially problematic rules) and will issue a warning if present. "$~[]$~False$~"Bugzilla/RedMine issue 2839 - Remove RULES in BioSQL PostgreSQL schema"$~2016-06-03T13:26:34Z$~2016-06-03T13:44:26Z$~None$~open$~peterjc$~63959$~None$~None$~[]
9f7eed8a1f068185ed8266161bec4d687b854822$~2016-01-05T10:32:39Z$~peterjc$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
802a0904f8f48cd035cc6acb4a1761d11a92c1ab$~2016-01-04T21:12:08Z$~hlapp$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
802a0904f8f48cd035cc6acb4a1761d11a92c1ab$~2016-01-04T21:12:08Z$~hlapp$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-04T15:09:13Z$~ctSkennerton$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-04T15:09:13Z$~ctSkennerton$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-02T00:34:27Z$~hlapp$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-02T00:34:27Z$~hlapp$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-01T19:24:02Z$~ctSkennerton$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-01T19:24:02Z$~ctSkennerton$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-01T03:20:46Z$~hlapp$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-01T03:20:46Z$~hlapp$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-01T03:20:46Z$~chapmanb$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2016-01-01T03:20:46Z$~chapmanb$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
d2eba1923d25db5b1783a161dafaa1933df033e6$~2015-12-31T06:50:36Z$~ctSkennerton$~"Increased support for SQLite by adding foreign key constraints to the database to bring it inline with the other databases and updated the `load_ncbi_taxonomy.pl` script to support SQLite "$~[]$~False$~"Sqlite foreign keys"$~2015-12-31T06:48:40Z$~2016-01-05T14:26:37Z$~None$~closed$~ctSkennerton$~685235$~None$~2016-01-04T21:12:08Z$~[]
None$~2015-12-31T06:46:51Z$~ctSkennerton$~""$~[]$~False$~"added support for SQLite in load_ncbi_taxonomy.pl"$~2014-11-20T19:34:15Z$~2015-12-31T06:46:51Z$~None$~closed$~ctSkennerton$~685235$~None$~2015-12-31T06:46:51Z$~[]
None$~2013-05-13T19:13:00Z$~hlapp$~"My institute network is behind a proxy. I have an environment proxy defined in the  ~/.bashrc file  http_proxy=http://username:password@proxy.network.com:port/ https_proxy=http://username:password@proxy.network.com:port/  ftp_proxy=http://username:password@proxy.network.com:port/  I removed the Perl's Net:FTP module dependency and am using LWP:UserAgent for proxy support. "$~[]$~False$~"Environment Proxy Support for the load_ncbi_taxonomy.pl script"$~2013-05-13T15:43:29Z$~2014-07-11T11:09:55Z$~None$~closed$~saketkc$~682153$~None$~2013-05-13T19:13:00Z$~[]
29025a865ec892ee6ff686e48921149acb07dc7e$~2013-05-13T19:13:00Z$~hlapp$~"My institute network is behind a proxy. I have an environment proxy defined in the  ~/.bashrc file  http_proxy=http://username:password@proxy.network.com:port/ https_proxy=http://username:password@proxy.network.com:port/  ftp_proxy=http://username:password@proxy.network.com:port/  I removed the Perl's Net:FTP module dependency and am using LWP:UserAgent for proxy support. "$~[]$~False$~"Environment Proxy Support for the load_ncbi_taxonomy.pl script"$~2013-05-13T15:43:29Z$~2014-07-11T11:09:55Z$~None$~closed$~saketkc$~682153$~None$~2013-05-13T19:13:00Z$~[]
29025a865ec892ee6ff686e48921149acb07dc7e$~2013-05-13T19:13:00Z$~hlapp$~"My institute network is behind a proxy. I have an environment proxy defined in the  ~/.bashrc file  http_proxy=http://username:password@proxy.network.com:port/ https_proxy=http://username:password@proxy.network.com:port/  ftp_proxy=http://username:password@proxy.network.com:port/  I removed the Perl's Net:FTP module dependency and am using LWP:UserAgent for proxy support. "$~[]$~False$~"Environment Proxy Support for the load_ncbi_taxonomy.pl script"$~2013-05-13T15:43:29Z$~2014-07-11T11:09:55Z$~None$~closed$~saketkc$~682153$~None$~2013-05-13T19:13:00Z$~[]

